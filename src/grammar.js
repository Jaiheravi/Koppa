// Generated automatically by nearley, version 2.18.0
// http://github.com/Hardmath123/nearley
(function () {
function id(x) { return x[0]; }

  const AST = require("./ast.js")
  const lexer = require("./lexer.js")
var grammar = {
    Lexer: lexer,
    ParserRules: [
    {"name": "Program$ebnf$1", "symbols": []},
    {"name": "Program$ebnf$1$subexpression$1", "symbols": ["Declaration", "_"]},
    {"name": "Program$ebnf$1", "symbols": ["Program$ebnf$1", "Program$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "Program", "symbols": ["_", "Program$ebnf$1"], "postprocess": AST.Declaration},
    {"name": "Declaration", "symbols": ["Comment"], "postprocess": AST.Id},
    {"name": "Declaration", "symbols": ["Import"], "postprocess": AST.Id},
    {"name": "Declaration", "symbols": ["Definition"], "postprocess": AST.Id},
    {"name": "Declaration", "symbols": [(lexer.has("shebang") ? {type: "shebang"} : shebang)], "postprocess": AST.Literal},
    {"name": "Import$subexpression$1", "symbols": ["Identifier"]},
    {"name": "Import$subexpression$1", "symbols": ["RecordPattern"]},
    {"name": "Import", "symbols": ["Import$subexpression$1", "__", {"literal":"from"}, "__", "String"], "postprocess": AST.Import},
    {"name": "RecordPattern$ebnf$1", "symbols": []},
    {"name": "RecordPattern$ebnf$1$subexpression$1", "symbols": ["_", {"literal":","}, "_", "Identifier"]},
    {"name": "RecordPattern$ebnf$1", "symbols": ["RecordPattern$ebnf$1", "RecordPattern$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "RecordPattern", "symbols": [{"literal":"{"}, "_", "Identifier", "RecordPattern$ebnf$1", "_", {"literal":"}"}], "postprocess": AST.RecordPattern},
    {"name": "Definition$ebnf$1$subexpression$1", "symbols": [{"literal":"public"}, "__"]},
    {"name": "Definition$ebnf$1", "symbols": ["Definition$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "Definition$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "Definition$ebnf$2$subexpression$1", "symbols": ["__", "Where"]},
    {"name": "Definition$ebnf$2", "symbols": ["Definition$ebnf$2$subexpression$1"], "postprocess": id},
    {"name": "Definition$ebnf$2", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "Definition", "symbols": ["Definition$ebnf$1", "Identifier", "__", {"literal":"="}, "__", "Expression", "Definition$ebnf$2"], "postprocess": AST.Definition},
    {"name": "Where$ebnf$1", "symbols": []},
    {"name": "Where$ebnf$1$subexpression$1", "symbols": [{"literal":","}, "__", "InnerDefinition"]},
    {"name": "Where$ebnf$1", "symbols": ["Where$ebnf$1", "Where$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "Where", "symbols": [{"literal":"where"}, "__", "InnerDefinition", "Where$ebnf$1"], "postprocess": AST.Where},
    {"name": "InnerDefinition", "symbols": ["Identifier", "__", {"literal":"="}, "__", "Expression"], "postprocess": AST.InnerDefinition},
    {"name": "Expression", "symbols": ["FunctionComposition"], "postprocess": AST.Id},
    {"name": "Expression", "symbols": ["FunctionDefinition"], "postprocess": AST.Id},
    {"name": "Expression", "symbols": ["FunctionApplication"], "postprocess": AST.Id},
    {"name": "Expression", "symbols": ["Conditional"], "postprocess": AST.Id},
    {"name": "Expression", "symbols": ["PrimitiveExpression"], "postprocess": AST.Id},
    {"name": "FunctionComposition$ebnf$1", "symbols": []},
    {"name": "FunctionComposition$ebnf$1$subexpression$1", "symbols": ["__", {"literal":"|>"}, "__", "ApplicableExpression"]},
    {"name": "FunctionComposition$ebnf$1", "symbols": ["FunctionComposition$ebnf$1", "FunctionComposition$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "FunctionComposition", "symbols": ["FunctionApplication", "__", {"literal":"|>"}, "__", "ApplicableExpression", "FunctionComposition$ebnf$1"], "postprocess": AST.FunctionComposition},
    {"name": "FunctionDefinition$ebnf$1$subexpression$1", "symbols": ["Identifier", "__"]},
    {"name": "FunctionDefinition$ebnf$1", "symbols": ["FunctionDefinition$ebnf$1$subexpression$1"]},
    {"name": "FunctionDefinition$ebnf$1$subexpression$2", "symbols": ["Identifier", "__"]},
    {"name": "FunctionDefinition$ebnf$1", "symbols": ["FunctionDefinition$ebnf$1", "FunctionDefinition$ebnf$1$subexpression$2"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "FunctionDefinition", "symbols": ["FunctionDefinition$ebnf$1", {"literal":"=>"}, "__", "DefinableExpression"], "postprocess": AST.FunctionDefinition},
    {"name": "FunctionApplication$ebnf$1$subexpression$1", "symbols": ["__", "PrimitiveExpression"]},
    {"name": "FunctionApplication$ebnf$1", "symbols": ["FunctionApplication$ebnf$1$subexpression$1"]},
    {"name": "FunctionApplication$ebnf$1$subexpression$2", "symbols": ["__", "PrimitiveExpression"]},
    {"name": "FunctionApplication$ebnf$1", "symbols": ["FunctionApplication$ebnf$1", "FunctionApplication$ebnf$1$subexpression$2"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "FunctionApplication", "symbols": ["Identifier", "FunctionApplication$ebnf$1"], "postprocess": AST.FunctionApplication},
    {"name": "Conditional$ebnf$1$subexpression$1", "symbols": ["__", {"literal":"else"}, "__", "DefinableExpression"]},
    {"name": "Conditional$ebnf$1", "symbols": ["Conditional$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "Conditional$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "Conditional", "symbols": [{"literal":"if"}, "__", "LogicExpression", "__", {"literal":"then"}, "__", "DefinableExpression", "Conditional$ebnf$1"], "postprocess": AST.Conditional},
    {"name": "PrimitiveExpression", "symbols": ["GroupExpression"], "postprocess": AST.Id},
    {"name": "PrimitiveExpression", "symbols": ["UnaryExpression"], "postprocess": AST.Id},
    {"name": "PrimitiveExpression", "symbols": ["BinaryExpression"], "postprocess": AST.Id},
    {"name": "PrimitiveExpression", "symbols": ["RecordExpression"], "postprocess": AST.Id},
    {"name": "PrimitiveExpression", "symbols": ["ListExpression"], "postprocess": AST.Id},
    {"name": "PrimitiveExpression", "symbols": ["ListAccessExpression"], "postprocess": AST.Id},
    {"name": "PrimitiveExpression", "symbols": ["Identifier"], "postprocess": AST.Id},
    {"name": "PrimitiveExpression", "symbols": ["Number"], "postprocess": AST.Id},
    {"name": "PrimitiveExpression", "symbols": ["String"], "postprocess": AST.Id},
    {"name": "PrimitiveExpression", "symbols": ["Boolean"], "postprocess": AST.Id},
    {"name": "PrimitiveExpression", "symbols": ["Regex"], "postprocess": AST.Id},
    {"name": "PrimitiveExpression", "symbols": ["EmptyKeyword"], "postprocess": AST.Id},
    {"name": "ApplicableExpression", "symbols": ["Identifier"], "postprocess": AST.Id},
    {"name": "ApplicableExpression", "symbols": ["FunctionDefinition"], "postprocess": AST.Id},
    {"name": "ApplicableExpression", "symbols": ["FunctionApplication"], "postprocess": AST.Id},
    {"name": "DefinableExpression", "symbols": ["Conditional"], "postprocess": AST.Id},
    {"name": "DefinableExpression", "symbols": ["FunctionComposition"], "postprocess": AST.Id},
    {"name": "DefinableExpression", "symbols": ["FunctionApplication"], "postprocess": AST.Id},
    {"name": "DefinableExpression", "symbols": ["PrimitiveExpression"], "postprocess": AST.Id},
    {"name": "LogicExpression", "symbols": ["UnaryExpression"], "postprocess": AST.Id},
    {"name": "LogicExpression", "symbols": ["BinaryExpression"], "postprocess": AST.Id},
    {"name": "LogicExpression", "symbols": ["Identifier"], "postprocess": AST.Id},
    {"name": "LogicExpression", "symbols": ["Boolean"], "postprocess": AST.Id},
    {"name": "GroupExpression", "symbols": [{"literal":"("}, "_", "Expression", "_", {"literal":")"}], "postprocess": AST.GroupExpression},
    {"name": "UnaryExpression", "symbols": [(lexer.has("unaryOperator") ? {type: "unaryOperator"} : unaryOperator), "PrimitiveExpression"], "postprocess": AST.UnaryExpression},
    {"name": "BinaryExpression", "symbols": ["PrimitiveExpression", "__", (lexer.has("binaryOperator") ? {type: "binaryOperator"} : binaryOperator), "__", "PrimitiveExpression"], "postprocess": AST.BinaryExpression},
    {"name": "RecordExpression", "symbols": [{"literal":"{"}, "_", "RecordBody", "_", {"literal":"}"}], "postprocess": AST.RecordExpression},
    {"name": "RecordBody$ebnf$1", "symbols": []},
    {"name": "RecordBody$ebnf$1$subexpression$1", "symbols": ["_", {"literal":","}, "_", "RecordEntry"]},
    {"name": "RecordBody$ebnf$1", "symbols": ["RecordBody$ebnf$1", "RecordBody$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "RecordBody", "symbols": ["RecordEntry", "RecordBody$ebnf$1"], "postprocess": AST.RecordBody},
    {"name": "RecordEntry$ebnf$1$subexpression$1", "symbols": ["Comment", "_"]},
    {"name": "RecordEntry$ebnf$1", "symbols": ["RecordEntry$ebnf$1$subexpression$1"], "postprocess": id},
    {"name": "RecordEntry$ebnf$1", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "RecordEntry$subexpression$1", "symbols": ["Identifier"]},
    {"name": "RecordEntry$subexpression$1", "symbols": ["String"]},
    {"name": "RecordEntry$ebnf$2$subexpression$1", "symbols": ["_", {"literal":":"}, "_", "Expression"]},
    {"name": "RecordEntry$ebnf$2", "symbols": ["RecordEntry$ebnf$2$subexpression$1"], "postprocess": id},
    {"name": "RecordEntry$ebnf$2", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "RecordEntry$ebnf$3$subexpression$1", "symbols": ["_", "Comment"]},
    {"name": "RecordEntry$ebnf$3", "symbols": ["RecordEntry$ebnf$3$subexpression$1"], "postprocess": id},
    {"name": "RecordEntry$ebnf$3", "symbols": [], "postprocess": function(d) {return null;}},
    {"name": "RecordEntry", "symbols": ["RecordEntry$ebnf$1", "RecordEntry$subexpression$1", "RecordEntry$ebnf$2", "RecordEntry$ebnf$3"], "postprocess": AST.RecordEntry},
    {"name": "ListExpression$ebnf$1", "symbols": []},
    {"name": "ListExpression$ebnf$1$subexpression$1", "symbols": [{"literal":","}, "_", "PrimitiveExpression", "_"]},
    {"name": "ListExpression$ebnf$1", "symbols": ["ListExpression$ebnf$1", "ListExpression$ebnf$1$subexpression$1"], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "ListExpression", "symbols": [{"literal":"["}, "_", "PrimitiveExpression", "_", "ListExpression$ebnf$1", {"literal":"]"}], "postprocess": AST.ListExpression},
    {"name": "ListAccessExpression", "symbols": ["Identifier", {"literal":"["}, "_", "DefinableExpression", "_", {"literal":"]"}], "postprocess": AST.ListAccessExpression},
    {"name": "Identifier", "symbols": [(lexer.has("identifier") ? {type: "identifier"} : identifier)], "postprocess": AST.Literal},
    {"name": "Number", "symbols": [(lexer.has("number") ? {type: "number"} : number)], "postprocess": AST.Literal},
    {"name": "String", "symbols": [(lexer.has("string") ? {type: "string"} : string)], "postprocess": AST.Literal},
    {"name": "Boolean", "symbols": [(lexer.has("boolean") ? {type: "boolean"} : boolean)], "postprocess": AST.Boolean},
    {"name": "Regex", "symbols": [(lexer.has("regex") ? {type: "regex"} : regex)], "postprocess": AST.Literal},
    {"name": "EmptyKeyword", "symbols": [(lexer.has("emptyKeyword") ? {type: "emptyKeyword"} : emptyKeyword)], "postprocess": AST.EmptyKeyword},
    {"name": "_$ebnf$1", "symbols": []},
    {"name": "_$ebnf$1", "symbols": ["_$ebnf$1", (lexer.has("ws") ? {type: "ws"} : ws)], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "_", "symbols": ["_$ebnf$1"], "postprocess": AST.Empty},
    {"name": "__$ebnf$1", "symbols": [(lexer.has("ws") ? {type: "ws"} : ws)]},
    {"name": "__$ebnf$1", "symbols": ["__$ebnf$1", (lexer.has("ws") ? {type: "ws"} : ws)], "postprocess": function arrpush(d) {return d[0].concat([d[1]]);}},
    {"name": "__", "symbols": ["__$ebnf$1"], "postprocess": AST.Empty},
    {"name": "Comment", "symbols": [(lexer.has("comment") ? {type: "comment"} : comment)], "postprocess": AST.Empty}
]
  , ParserStart: "Program"
}
if (typeof module !== 'undefined'&& typeof module.exports !== 'undefined') {
   module.exports = grammar;
} else {
   window.grammar = grammar;
}
})();
